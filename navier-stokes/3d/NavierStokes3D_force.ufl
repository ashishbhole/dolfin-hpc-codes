# Copyright (c) 2005 Johan Jansson (johanjan@math.chalmers.se)
# Licensed under the GNU GPL Version 2
#
# First added:  2005
# Last changed: 2006-03-28
#
# The bilinear form for the incompressible Navier-Stokes equations
# Compile this form with FFC: ffc -l dolfin_hpc NavierStokes3D.ufl.

# Needed for Nitsche boundary condition
import ufl

cell = "tetrahedron"

K1 = VectorElement("Lagrange", cell, 1)
# Dimension of domain
d = K1.cell().geometric_dimension()
K2 = FiniteElement("Lagrange", cell, 1)
K3 = FiniteElement("Discontinuous Lagrange", cell, 0)
K4 = VectorElement("Discontinuous Lagrange", cell, 0)

K = K1

v = TestFunction(K)
U = TrialFunction(K) # Vertex velocity
UP = Coefficient(K)
U0 = Coefficient(K)

P = Coefficient(K2)
nu = Coefficient(K3)
d1 = Coefficient(K3)
d2 = Coefficient(K3)
k = Coefficient(K3)

beta = Coefficient(K3) # Penalty parameter for the Nitsche condition
n = Coefficient(K)


ff = as_vector([32*nu for i in range(d)]); # Source function. Scalar for now, what should it be?

# Get mesh coordinates and facet normals
x = ufl.SpatialCoordinate(v.ufl_domain())
#n = ufl.FacetNormal(v.ufl_domain())

# xmin and xmax to define inflow and outflow boundaries where Nitsche should not be applied
xmin = 0.0
xmax = 2.1
zmin = 0.0;
zmax = 0.4;
xcenter = 0.5
ycenter = 0.7
radius = 0.05
DOLFIN_EPS = 1e-6

# Phase function, true for all boundaries except inflow and outflow
# apply_nitsche = conditional(And(ge(x[0], xmin + DOLFIN_EPS), le(x[0], xmax - DOLFIN_EPS)), 1.0, 0.0)
apply_nitsche = conditional(And(And(((x[0] - xcenter)*(x[0] - xcenter) + (x[1] - ycenter)*(x[1] - ycenter)) - DOLFIN_EPS < (radius * radius), x[2] < zmax - DOLFIN_EPS), x[2] > zmin + DOLFIN_EPS), 1.0, 0.0)

def ugradu(u, v):
    return as_vector([dot(u, grad(v[i])) for i in range(d)])

def f(u, v):
    return -inner(ugradu(UP, u), v) + \
    inner((P*Identity(d) - nu*grad(u)), grad(v)) + \
    -inner(d2*div(u), div(v)) + \
    -d1*inner(ugradu(UP, u), ugradu(UP, v)) + \
    inner(ff,v)

def dfdu(u, v):
    return -inner(ugradu(UP, u), v) + \
    -nu*inner(grad(u), grad(v)) + \
    -d2*dot(div(u), div(v)) + \
    -d1*dot(ugradu(UP, u), ugradu(UP, v))

# cG(1)
def F(u, u0, k, v):
    uc = 0.5*(u + u0)
    return (-inner(u, v) + inner(u0, v) + k*f(uc, v))

def dFdu(u, k, v):
    uc = 0.5*u
    return (-inner(u, v) + k*dfdu(uc, v))

a = (dFdu(U, k, v)) * dx + (apply_nitsche * beta * dot(U, n)*dot(v,n)) * ds
L = (dFdu(UP, k, v) - F(UP, U0, k, v)) * dx
